# Общие задачи для всех серверов
- name: Убедиться что python установлен
  raw: test -e /usr/bin/python || (apt -y update && apt install -y python3)
  changed_when: false

- name: Установить необходимые системные пакеты
  apt:
    name:
      - "{{ postgresql_common_package }}"
      - gnupg
      - curl
      - ca-certificates
      - python3-pip
      - acl
    state: present
    update_cache: yes

- name: Установить psycopg2-binary для серверов приложений
  pip:
    name: psycopg2-binary
    state: present
    executable: /usr/bin/pip3

# Установить PostgreSQL-клиент и утилиты на серверы приложений
- name: Установить PostgreSQL-клиент на серверы приложений
  apt:
    name: postgresql-client
    state: present
  when: "'app' in group_names"

# Задачи для master и replica
- name: Установить сервер PostgreSQL и настроить общие параметры
  block:
    - name: Запуск скрипта PostgreSQL PGDG
      shell: "{{ postgresql_repo_path }} -y"
      args:
        creates: /etc/apt/sources.list.d/pgdg.list
      changed_when: false

    - name: Создать директорию для ключа репозитория PostgreSQL
      file:
        path: /usr/share/postgresql-common/pgdg
        state: directory
        mode: '0755'
      changed_when: false

    - name: Скачать ключ подписи репозитория PostgreSQL
      get_url:
        url: "{{ postgresql_key_url }}"
        dest: "{{ postgresql_key }}"
        mode: '0644'
      changed_when: false

    - name: Проверить наличие репозитория PGDG
      stat:
        path: "{{ postgresql_sources_list }}"
      register: pgdg_repo

    - name: Добавить репозиторий PostgreSQL в список источников
      shell: |
        echo "deb [signed-by={{ postgresql_key }}] {{ postgresql_repo_url }} $(lsb_release -cs)-pgdg main" > {{ postgresql_sources_list }}
      when: not pgdg_repo.stat.exists
      changed_when: false

    - name: Обновить список пакетов
      apt:
        update_cache: yes

    - name: Установить сервер PostgreSQL
      apt:
        name: "{{ postgresql_package }}"
        state: present
        force: yes

    - name: Настроить pg_hba.conf
      template:
        src: templates/pg_hba.conf
        dest: "{{ pg_hba_conf_path }}"
        owner: postgres
        group: postgres
        mode: '0644'
      notify:
        - Перезапустить службу PostgreSQL
  when: "'master' in group_names or 'replica' in group_names"

# Конфигурация Master Node
- name: Настроить мастер-узел
  block:
    - name: Убедитесь, что служба PostgreSQL запущена на мастере
      shell: |
        pg_ctlcluster {{ postgresql_version }} main start
      args:
        executable: /bin/bash
      register: postgresql_start_master
      changed_when: "'server starting' in postgresql_start_master.stdout"
      failed_when: "'already running' not in postgresql_start_master.stdout and postgresql_start_master.rc != 0 and 'server starting' not in postgresql_start_master.stdout"

    - name: Настроить postgresql.conf для мастера
      blockinfile:
        path: "{{ pg_conf_path }}"
        block: |
          listen_addresses = '{{ postgresql_master_listen_addresses }}'
          wal_level = {{ postgresql_master_wal_level }}
          archive_mode = {{ postgresql_master_archive_mode }}
          archive_command = '{{ postgresql_master_archive_command }}'
          max_wal_senders = {{ postgresql_master_max_wal_senders }}
          hot_standby = {{ postgresql_master_hot_standby }}
      changed_when: false

    - name: Создать базу данных PostgreSQL
      become_user: postgres
      postgresql_db:
        name: "{{ postgresql_db_name }}"
      register: db_creation
      changed_when: db_creation.changed

    - name: Создать пользователя PostgreSQL
      become_user: postgres
      postgresql_user:
        name: "{{ postgresql_user_name }}"
      register: user_creation
      changed_when: user_creation.changed

    - name: Перезапустить службу PostgreSQL на мастере
      shell: |
        pg_ctlcluster {{ postgresql_version }} main restart
      args:
        executable: /bin/bash
      register: restart_result
      changed_when: "'server starting' in restart_result.stdout or 'restarted' in restart_result.stdout"
      failed_when: "'stopped' in restart_result.stdout or restart_result.rc != 0"
  when: "'master' in group_names"

# Конфигурация Replica Node
- name: Настроить репликационный узел
  block:
    - name: Проверить статус службы PostgreSQL на реплике
      shell: |
        pg_lsclusters | grep "{{ postgresql_version }}" | grep main | awk '{print $3}'
      args:
        executable: /bin/bash
      register: replica_status
      changed_when: false

    - name: Остановить службу PostgreSQL на реплике, если она запущена
      shell: |
        pg_ctlcluster {{ postgresql_version }} main stop
      args:
        executable: /bin/bash
      register: replica_stop
      changed_when: "'server stopped' in replica_stop.stdout"
      failed_when: "'is not running' not in replica_stop.stdout and replica_stop.rc != 0"
      when: replica_status.stdout.strip() == "online"

    - name: Проверить, существует ли директория данных PostgreSQL
      stat:
        path: "{{ postgresql_data_dir }}"
      register: data_dir_status
      become_user: postgres

    - name: Удалить существующие данные PostgreSQL и создать новую директорию
      shell: |
        rm -rf {{ postgresql_data_dir }} &&
        mkdir -p {{ postgresql_data_dir }} &&
        chmod go-rwx {{ postgresql_data_dir }}
      args:
        executable: /bin/bash
      become_user: postgres
      when: data_dir_status.stat.exists
      changed_when: false

    - name: Проверить, существует ли файл standby.signal
      stat:
        path: "{{ postgresql_data_dir }}/standby.signal"
      register: standby_signal_check
      become_user: postgres

    - name: Выполнить базовую резервную копию с мастера на реплику
      command: >
        pg_basebackup -P -R -X stream -c fast -h {{ master_host }} -U {{ replication_user }} -D "{{ postgresql_data_dir }}"
      args:
        creates: "{{ postgresql_data_dir }}/standby.signal"
      become_user: postgres
      when: not standby_signal_check.stat.exists
      changed_when: false

    - name: Настроить postgresql.conf для реплики
      blockinfile:
        path: "{{ pg_conf_path }}"
        block: |
          primary_conninfo = 'host={{ master_host }} port=5432 user={{ replication_user }}'
          hot_standby = on
      changed_when: false

    - name: Убедитесь, что нет конфликтующих процессов PostgreSQL на реплике
      shell: |
        ps aux | grep '[p]ostgres' | awk '{print $2}' | xargs -r kill -9
        ps aux | grep '[p]ostgres' | wc -l
      args:
        executable: /bin/bash
      register: postgres_kill
      ignore_errors: true
      changed_when: postgres_kill.stdout | int > 0

    - name: Запустить службу PostgreSQL для реплики
      shell: |
        pg_ctlcluster {{ postgresql_version }} main start
      args:
        executable: /bin/bash
      register: replica_start
      changed_when: "'server starting' in replica_start.stdout"
      failed_when: "'already running' not in replica_start.stdout and 'port conflict' not in replica_start.stderr and replica_start.rc != 0"
  when: "'replica' in group_names"
